forward int red;
forward int blue;
forward int green;
forward void<int, int, string<int, int, [int]>> display;

forward [double]<double, double, [double]> vec2;
forward [double]<double, double, double, [double]> vec3;
forward [double]<[double], [double], [double]> add3;
forward [double]<[double], double, [double]> mul3;
forward double<[double]> len3;
forward double<[double], [double]> distance3sq;
forward double<double> cos;
forward double<double> sin;

int w = 100;
int h = 22;
double zFar = 10.0;

int objectsSize = 0;
int maxObjectsSize = 64;
[int<[double], [int]>] objects = null;

int frame = 0;

auto raycast = ([double] origin, [double] step, [int] color) -> double {
    int i;
    double z = 0.0;
    double stepLen = len3(step);

    while (z < zFar) {
        z = z + stepLen;
        add3(origin, step, origin);

        // Check if any object is intersecting.
        i = 0;
        while (i < objectsSize) {
            if (objects[i](origin, color)) {
                return z;
            }

            i = i + 1;
        }
    }

    color[0] = red;
    return zFar;
};

auto fragment = (int x, int y, [int] color) -> string {
    // Get the normalized screen coordinates.
    double depth;
    double dw = w;
    double dh = h;
    double ar = 1.8;
    auto coords = vec2(((x / dw) * 2.0 - 1.0) * ar, (y / dh) * 2.0 - 1.0, [2]);

    // Cast a ray.
    auto origin = vec3(coords[0], coords[1], 0.0, [3]);
    auto step = vec3(coords[0], coords[1], 10.0, [3]);
    mul3(step, 0.5 / len3(step), step);

    depth = raycast(origin, step, color);
    if (depth >= zFar) {
        color[0] = blue;
        return "#";
    } else {
        if (depth < 1.0 * zFar / 8.0)
            return "@";
        else if (depth < 2.0 * zFar / 8.0)
            return "X";
        else if (depth < 3.0 * zFar / 8.0)
            return "S";
        else if (depth < 4.0 * zFar / 8.0)
            return "%";
        else if (depth < 5.0 * zFar / 8.0)
            return "t";
        else if (depth < 6.0 * zFar / 8.0)
            return ";";
        else if (depth < 7.0 * zFar / 8.0)
            return ":";
        else
            return "."; 
    }
};

auto pushObject = (int<[double], [int]> object) -> void {
    if (objectsSize >= maxObjectsSize) {
        return;
    }

    objects[objectsSize] = object;
    objectsSize = objectsSize + 1;
};

auto sleep = (int count) -> void {
    count = count * 1000000;
    while (count > 0) {
        count = count - 1;
    }
};

begin
    objects = [maxObjectsSize];
    
    pushObject(([double] point, [int] color) -> int {
        auto center = vec3(0, 0, 5, [3]);

        if (distance3sq(point, center) > 0.5) {
            return 0;
        }

        color[0] = red;
        return 1;
    });

    pushObject(([double] point, [int] color) -> int {
        auto t = frame * 0.3;
        auto center = vec3(1.5 * cos(t), 0, 5 + 1.5 * sin(t), [3]);

        if (distance3sq(point, center) > 0.3) {
            return 0;
        }

        color[0] = green;
        return 1;
    });

    while (1) {
        display(w, h, fragment);
        sleep(50);
        frame = frame + 1;
    }
end
